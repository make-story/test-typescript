/*
-
선언형 프로그래밍과 배열
함수형 프로그래밍은 선언형 프로그래밍(declarative programming)과 깊은 관련이 있습니다.
배열은 선언형 프로그래밍을 구현할 때 절대적으로 필요한 문법 기능입니다.
선연형 프로그래밍은 곧잘 명령형 프로그래밍(imperative progrmming)과 비교되지만, 이 둘은 대등하게 비교할 대상은 아닙니다.

명령형은 좀 더 CPU 치화적인 저수준(low-level) 구현방식이고, 선언형은 명령형 방식 위에서 동작하는 인간에게 좀 더 친화적인 고수준(high-level)구현 방식입니다.


-
명령형 프로그래밍이란
프로그램의 기본 형태는 다음처럼 입력 데이터를 얻고 가공한 다음, 결과를 출력하는 형태로 구성됩니다.
- 입력 데이터 얻기
- 입력 데이터 가공해 출력 데이터 생성
- 출력 데이터 출력

명령형 프로그래밍에서는 여러 개의 데이터를 대상으로 할 때 다음처럼 for 문을 사용해서 구현합니다.
for( ; ; ) {
    입력 데이터 얻기
    입력 데이터 가공해 출력 데이터 생성
    출력 데이터 출력
}

반면에 선언형 프로그래밍은 시스템 자원의 효율적인 운용보다는 일괄된 문제 해결 구조에 더 집중합니다.
선언형 프로그래밍은 명령형 프로그래밍처럼 for 문을 사용하지 않고 모든 데이터를 배열에 담습니다.
그리고 문제가 해결될 때까지 끊임없이 또 다른 형태의 배열로 가공하는 방식으로 구형합니다.
- 문제를 푸는 데 필요한 모든 데이터 배열에 저장
- 입력 데이터 배열을 가공해 출력 데이터 배열 생성
- 출력 데이터 배열에 담긴 아이템 출력

(명령령 코드는 데이터와 가공이 for문 안에서 이루어졌지만, 선언형은 데이터 생성과 가공 과정을 분리합니다.)


-
순수 함수와 배열
함수형 프로그래밍에서 함수는 '순수 함수(pure function)'이라는 조건을 만족해야 합니다.
그러나 타입스크립트의 Array 클래스에는 순수 함수 조건에 부합하지 않는 메서드가 많습니다.
따라서 타입스크립트로 함수형 프로그래밍을 하면서 배열의 메서드를 사용할 때는 해당 메서드가 어떤 특성이 있는지 살펴야 합니다.


- 
순수 함수란?
순수 함수는 부수 효과(side-effect)가 없는 함수를 말합니다.
여기서 부수 효과란 함수가 가진 고유한 목적 이외에 다른 효과가 나타나는 것을 의미하며 부작용이라고도 합니다.
반면에 부수 효과가 있는 함수는 '불순 함수(impure function)'라고 합니다.

함수형 프로그래밍에서 발생하는 부수 효과는 함수를 순수 함수 형태로 작성해야만 제거할 수 있습니다.
어떤 함수가 부수 효과가 없는 순수한 함수이려면 다음과 같은 조건을 충족해야 합니다.
- 함수 몸통에 압출력 관련 코드가 없어야 한다.
- 함수 몸통에서 매개변수값을 변경시키지 않는다. (즉, 매개변수는 const 나 readonly 형태로만 사용한다.)
- 함수는 몸통에서 만들어진 결과를 즉시 반환한다.
- 함수 내부에 전역 변수나 정적 변수를 사용하지 않는다.
- 함수가 예외를 발생시키지 않는다.
- 함수가 콜백 함수로 구현되었거나 함수 몸통에 콜백 함수를 사용하는 코드가 없다.
- 함수 몸통에 Promise 와 같은 비동기 방식으로 동작하는 코드가 없다.


-
함수형 프로그래밍은 순수 함수와 선언형 프로그래밍의 토대 위에 함수 조합(function composition)과 모나드 조합(monadic composition)으로 코드를 설계하고 구현하는 기법입니다.
함수형 프로그래밍은 다음 세 가지 수학 이론에 기반을 두고 있습니다.
- 람다 수학(ramda calculus): 조합 논리와 카테고리 이론의 토대가 되는 논리 수학
- 조합 논리(combinatory logic): 함수 조합의 이론적 배경
- 카테고리 이론(category theory): 모나드 조합과 고차 타입의 이론적 배경
*/
// 타입 수정자 readonly
// 타입 스크립트는 순수 함수 구현을 쉽게 하도록 readonly 키워드를 제공합니다.
function forcePure(array: readonly number []) {
    // array.push(1) // 에러가 발생한다! readonly
}

// 전개 연산자와 깊은 복사
const oArray = [1, 2, 3, 4];
const deepCopiedArray = [...oArray];
deepCopiedArray[0] = 0;
console.log(oArray, deepCopiedArray); // [1, 2, 3, 4] [0, 2, 3, 4]


/*
-
튜플 이해하기
보통 튜블을 사용할 때는 타입 별칭(alias)으로 튜플의 의미를 명확하게 합니다.
예를 들어, [boolean, string]이라고 타입을 지정하는 것보다 다음처럼 타입 별칭을 사용해 이 튜플이 어떤 용도로 사용되는지 좀 더 분명하게 알려주는 것이 좋습니다.
*/
export type ResultType = [boolean, string];
export const doSomething = (): ResultType => {
    return [false, 'test'];
}